% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/TestFunctions.R
\name{testFunction_encompassingPriors}
\alias{testFunction_encompassingPriors}
\title{Test Function: Encompassing Priors}
\usage{
testFunction_encompassingPriors(priorEffects, postEffects, I_M0)
}
\arguments{
\item{priorEffects}{A numeric matrix of prior effect parameters. Rows are samples and columns parameters.}

\item{postEffects}{A numeric matrix of posterior effect parameters. Rows are samples and columns parameters.}

\item{I_M0}{The indicator function for the constrained model, \code{M_0}. This is a function that takes a vector of effect parameters, checks some constraint on those parameters, and returns 1 (or \code{TRUE}) if the constraint is satisfied or 0 (or \code{FALSE}) if the constraint is not satisfied.}
}
\value{
A list for the following elements:
\itemize{
\item \code{bf10}: The Bayes factor in favor of the encompassing/alternative model, \code{M_1}.
\item \code{bf01}: The Bayes factor in favor of the constrained/null model, \code{M_0}.
\item \code{prior_pSat}, \code{post_pSat}: The proportions of the prior and posterior, respectively, that satisfy the constraint of \code{I_M0}. If these are both very low, it indicates that your constraint is possibly too narrow and that the estimated Bayes factor may be noisy.
}
}
\description{
See the manual for this package for more information about the encompassing priors approach. There is some encompassing model, \code{M_1}, and a constrained model, \code{M_0}, which is created by placing some constraint on the parameters of \code{M_1}. The function \code{I_M0} that is passed to this function determines whether the constraint is satisfied.

Note that you cannot pass this function directly as the \code{testFunction} argument of \code{\link{testHypothesis}} because there is no default value for \code{I_M0}. Thus, you must create a curried function to pass to \code{\link{testHypothesis}}. See the examples.
}
\examples{
\dontrun{
curriedTestFun = function(priorEffects, postEffects) {
  #M_0: Constrain the effects to be less than 2 units from 0
  I_M0 = function(eff) {
    all(abs(eff) < 2)
  }
  testFunction_encompassingPriors(priorEffects, postEffects, I_M0)
}

testHypothesis(..., testFunction = curriedTestFun)
}
}
